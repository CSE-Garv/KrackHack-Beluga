import os
import yara
import pefile
import hashlib
import math
import re
import PyPDF2
import olefile
from ctypes import cdll


path=os.getcwd()

# Load YARA DLL manually (Windows-specific)
YARA_DLL_PATH = path+'\\myenv\\DLLs\\libyara.dll'
if os.path.exists(YARA_DLL_PATH):
    os.add_dll_directory(os.path.dirname(YARA_DLL_PATH))
    cdll.LoadLibrary(YARA_DLL_PATH)
else:
    print("[ERROR] YARA DLL not found at", YARA_DLL_PATH)

# Risk Score Calculation (0 = Safe, 10 = High Risk)
def calculate_risk_score(entropy_score, yara_hits, pe_suspicious, doc_suspicious, regex_suspicious):
    score = 0

    if entropy_score > 7.5:
        score += 2  # High entropy suggests obfuscation
        print("DEBUG: High entropy (>{}): added 3 points. Current score: {}".format(7.5, score))
    elif entropy_score > 6.5:
        score += 1
        print("DEBUG: Moderate entropy (>{}): added 2 points. Current score: {}".format(6.5, score))

    if yara_hits:
        score += 4.5  # YARA match = strong indicator
        print("DEBUG: YARA match found: added 4 points. Current score: {}".format(score))

    # if pe_suspicious:
    #     score += 3  # Suspicious PE imports/API calls
    #     print("DEBUG: Suspicious PE elements detected: added 3 points. Current score: {}".format(score))

    if doc_suspicious:
        score += 3  # Macros or JavaScript in documents
        print("DEBUG: Suspicious document content detected: added 3 points. Current score: {}".format(score))

    if regex_suspicious:
        score += 1  # Regex detection
        print("DEBUG: Suspicious regex pattern detected: added 2 points. Current score: {}".format(score))

    final_score = min(score, 10)  # Ensure max score is 10
    print("DEBUG: Final risk score: {}".format(final_score))
    return final_score

# YARA Rules

rules = yara.compile(filepath="malware_rules.yar")

# Hash Lists
MALWARE_SHA256=[]
with open("Hash256.txt") as f:
    MALWARE_SHA256 = f.read().split()

MALWARE_MD5 = []
with open("MD5.txt") as f:
    MALWARE_MD5 = f.read().split()

MALWARE_SHA1=[]
with open("SHA1.txt") as f:
    MALWARE_SHA1 = f.read().split()


# Regex Patterns
SUSPICIOUS_PATTERNS = [
    # Process Injection Techniques (more specific ones)
    r"CreateRemoteThread(Ex)?\s*\(",
    r"NtCreateThreadEx\s*\(",
    r"QueueUserAPC\s*\(",
    r"WriteProcessMemory\s*\(",
    r"VirtualProtect(Ex)?\s*\(",
    
    # Process Hollowing
    r"ZwUnmapViewOfSection\s*\(",
    r"NtUnmapViewOfSection\s*\(",
    
    # API Hooking & Evasion (focused on lower‐level queries)
    r"NtQueryInformationProcess\s*\(",
    
    # Credential Theft (Windows API)
    r"CredEnumerate(A|W)?\s*\(",
    r"CryptProtectMemory\s*\(",
    r"CryptUnprotectMemory\s*\(",
    r"SamIConnect\s*\(",
    
    # Persistence Mechanisms (targeting explicit persistence locations/operations)
    r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",
    r"RegCreateKey(Ex)?\s*\(",
    
    # C2 Communication & Encoding (more targeted patterns)
    r"Base64Decode\s*\(",
    r"ConvertTo-SecureString",
    r"downloadstring\s*\(",
    
    # Code Obfuscation & Execution (specialized techniques)
    r"RunPE",
    r"ReflectiveLoader",
    r"ManualMap",
    
    # Ransomware-Specific Indicators
    r"CryptEncrypt\s*\(",
    r"CryptGenKey\s*\(",
    r"\.locked",
    r"\.enc",
    
    # Keylogger Detection
    r"GetAsyncKeyState\s*\(",
    r"GetForegroundWindow\s*\(",
    
    # Sandbox & Virtual Machine Detection
    r"VMware",
    r"VBox",
    r"QEMU",
    r"wireshark.exe",
    r"procmon.exe",
    r"ollydbg.exe",
    
    # Additional API Hooking indicator (used in DLL injection)
    r"LoadLibrary(A|W)?\s*\(",
]



def calculate_entropy(data):
    if not data:
        return 0
    entropy = 0
    length = len(data)
    freq = {char: data.count(char) for char in set(data)}
    for count in freq.values():
        probability = count / length
        entropy -= probability * math.log2(probability)
    
    return entropy

def check_entropy(filepath):
    try:
        with open(filepath, "rb") as file:
            return calculate_entropy(file.read())
    except Exception:
        return 0

def scan_hash(filepath):
    try:
        with open(filepath, "rb") as file:
            file_hash = hashlib.sha256(file.read()).hexdigest()
            if file_hash in MALWARE_SHA256:
                return True
    except Exception:
        pass
    try:
        with open(filepath, "rb") as file:
            file_hash = hashlib.md5(file.read()).hexdigest()
            if file_hash in MALWARE_MD5:
                return True
    except Exception:
        pass
    try:
        with open(filepath, "rb") as file:
            file_hash = hashlib.sha1(file.read()).hexdigest()
            if file_hash in MALWARE_SHA1:
                return True
    except Exception:
        pass
    return False

def yara_scan(filepath):
    try:
        return bool(rules.match(filepath))
    except Exception:
        return False
def analyze_pe(filepath):
    """Analyze a PE file for suspicious characteristics."""
    try:
        pe = pefile.PE(filepath)
        suspicious_imports = {
            "LoadLibraryA", "LoadLibraryW", "GetProcAddress", "VirtualAlloc", "VirtualProtect",
            "CreateRemoteThread", "WriteProcessMemory", "ReadProcessMemory", "OpenProcess",
            "WinExec", "ShellExecuteA", "ShellExecuteW", "TerminateProcess", "ExitProcess"
        }
        suspicious_sections = {".UPX"}  # Only flag packed sections
        high_entropy_threshold = 7.5  # Threshold for detecting packed sections
        
        found_suspicious_imports = set()
        if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                for imp in entry.imports:
                    if imp.name:
                        func_name = imp.name.decode()
                        if func_name in suspicious_imports:
                            found_suspicious_imports.add(func_name)

        high_entropy_sections = []
        for section in pe.sections:
            entropy = calculate_entropy(section.get_data())
            if entropy > high_entropy_threshold:
                high_entropy_sections.append((section.Name.decode().strip('\x00'), entropy))
        
        found_suspicious_sections = [
            section.Name.decode().strip('\x00')
            for section in pe.sections
            if section.Name.decode().strip('\x00') in suspicious_sections
        ]

        found_suspicious_exports = []
        if hasattr(pe, "DIRECTORY_ENTRY_EXPORT"):
            for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                if exp.name:
                    func_name = exp.name.decode()
                    if "malware" in func_name.lower() or "backdoor" in func_name.lower():
                        found_suspicious_exports.append(func_name)

        # Only return True if at least one suspicious indicator is found
        is_suspicious = bool(
            found_suspicious_imports or high_entropy_sections or found_suspicious_sections or found_suspicious_exports
        )
        
        return is_suspicious  # Return False if no suspicious indicators found

    except Exception as e:
        logging.error(f"PE Analysis Error: {e}")
        return False  # Default to safe if an error occurs


def analyze_pdf(filepath):
    try:
        with open(filepath, "rb") as file:
            reader = PyPDF2.PdfReader(file)
            for page in reader.pages:
                text = page.extract_text()
                if text and "JavaScript" in text:
                    return True
    except Exception:
        pass
    return False



def analyze_docx(filepath):
    try:
        if olefile.isOleFile(filepath):
            ole = olefile.OleFileIO(filepath)
            if "macros" in ole.listdir():
                return True
    except Exception:
        pass
    return False

def regex_scan(filepath):
    try:
        with open(filepath, "r", errors="ignore") as file:
            content = file.read()
            for pattern in SUSPICIOUS_PATTERNS:
                if re.search(pattern, content):
                    return True
    except Exception:
        pass
    return False

def scan_file(filepath):
    print("Scanning:", filepath)

    entropy_score = check_entropy(filepath)
    yara_hits = yara_scan(filepath)
    hash_match = scan_hash(filepath)
    pe_suspicious = analyze_pe(filepath) if filepath.endswith((".exe", ".dll")) else False
    doc_suspicious = analyze_pdf(filepath) if filepath.endswith(".pdf") else analyze_docx(filepath) if filepath.endswith(".docx") else False
    regex_suspicious = regex_scan(filepath)

    risk_score = calculate_risk_score(entropy_score, yara_hits, pe_suspicious, doc_suspicious, regex_suspicious)

    print("Risk Score:", risk_score, "/10")
    if risk_score >= 7:
        print("HIGH RISK: This file is likely malware!")
    elif risk_score >= 4:
        print("MEDIUM RISK: Some suspicious elements detected.")
    else:
        print("LOW RISK: No obvious threats detected.")

    print("Infected" if risk_score >= 7 else "Suspicious" if risk_score >= 4 else "Clean")


if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Error: No file path provided.")
        sys.exit(1)

    file_path = sys.argv[1]  # Get file path from command-line argument

    if os.path.exists(file_path):
        scan_file(file_path)
    else:
        print("File does not exist.")